//fonctions.cvoid th_controler (void *arg){  int new_osd;  int nouvelle_commande;  rt_printf ("th_controler :  initialisation du systeme\n");  initialiser_le_systeme();  t_printf("th_controler : Demarrage des threads\n");   //On donne suffisament de ressources pour que les 2 autres threads puissent demarrer  rt_sem_v(&semDemarrage, TM_INFINITE);  rt_sem_v(&semDemarrage, TM_INFINITE);  rt_printf("th_controler : Debut de l'éxecution de periodique à 80s\n");  rt_task_set_periodic(NULL, TM_NOW, 80000000000);  while (1)    {    rt_mutex_acquire (&mutexCommande, TM_INFINITE); //lecture de la nouvelle commande    nouvelle_commande = commande;    rt_mutex_release (&mutexCommande);    new_osd = calcul_osd(nouvelle_commande); //calcul du nouvel OSD    rt_mutex_acquire (&mutexOSDBuff, TM_INFINITE); //modification de OSD Buffer    osdBuffer = new_osd;    rt_mutex_release (&mutexOSDBuff);    rt_mutex_acquire (&mutexOSD, TM_INFINITE); //modification de OSD    osd = new_osd;    rt_mutex_release (&mutexOSD);    rt_task_wait_period(NULL);    rt_printf("th_controler  : Activation périodique\n");  }}void th_capture (void *arg){  DImage *image_capturée;  DMessage *message;  DJpegimage *jpegimage;  rt_printf ("th_capture :  en attente de demarrage\n");  rt_sem_p(&semDemarrage, TM_INFINITE);  rt_printf("th_capture : Demarrage Succes\n");  while (1)    {        image_capturée = d_new_image();        image_capturée = acquisition_image(image);        rt_sem_v(&semImageCapturee, TM_INFINITE); //synchronisation avec le thread th_display, image_capturée !        jpegimage = d_new_jpegimage();        d_jpegimage_compress(jpegimage,frame);        message = d_new_message();        d_message_put_jpeg_image(message,jpegimage);        rt_printf("th_capture  : Envoie de l'image capturée \n");        if (write_in_queue(&queueMsgGUI, message, sizeof (DMessage)) < 0) {message->free(message);}    }}void th_display (void *arg){  DImage *image_capturée;  DMessage *message;  DJpegimage *jpegimage;  rt_printf ("th_display :  en attente de demarrage\n");  rt_sem_p(&semDemarrage, TM_INFINITE);  rt_printf("th_display : Demarrage Succes\n");  while (1)    {        rt_sem_p(&semImageCapturee, TM_INFINITE); //synchronisation avec le thread th_capture, image_capturée ?        if ((err = rt_queue_read (&queueMsgGUI, &image_capturée, sizeof (DMessage), TM_INFINITE)) >= 0) {            rt_mutex_acquire (&mutexOSD, TM_INFINITE); //osd_var := Read_data(osd)            osd_var = osd;            rt_mutex_release (&mutexOSD);            img = encode(image_capturée, osd_var);            rt_mutex_acquire (&mutexBufferEcran, TM_INFINITE); //osd_var := Read_data(osd)            buffer_ecran = img;            rt_mutex_release (&mutexBufferEcran);      }      else  {rt_printf ("th_display : Error msg queue write: %s\n", strerror (-err));}    }}//global.hextern RT_TASK th_controler;extern RT_TASK th_display;extern RT_TASK th_capture; /* @descripteurs des mutex */ extern RT_MUTEX mutexCommande; extern RT_MUTEX mutexOSDBuff; extern RT_MUTEX mutexOSD; extern RT_MUTEX mutexBufferEcran; /* @descripteurs des sempahore */ extern RT_SEM semDemarrage; extern RT_SEM semImageCapturee; /* @descripteurs des files de messages */ extern RT_QUEUE queueMsgGUI; /* @variables partagées */ extern int osdbuffer; extern int osd; extern int commande; extern int buffer_ecran; /* @constantes */ extern int MSG_QUEUE_SIZE; extern int PRIORITY_THCONTROLER; extern int PRIORITY_THCAPTURE; extern int PRIORITY_THDISPLAY;//global.c RT_TASK th_controler; RT_TASK th_display; RT_TASK th_capture; RT_MUTEX mutexCommande; RT_MUTEX mutexOSDBuff; RT_MUTEX mutexOSD; RT_MUTEX mutexBufferEcran; RT_SEM semDemarrage; RT_SEM semImageCapturee; RT_QUEUE queueMsgGUI;  int MSG_QUEUE_SIZE = 10;  int PRIORITY_THCONTROLER = 60;  int PRIORITY_THDISPLAY = 70;  int PRIORITY_THCAPTURE = 80//main.cvoid initStruct(void) {    int err;    /* Creation des mutex */    if (err = rt_mutex_create(&mutexOSDBuff, NULL)) {        rt_printf("Error mutex create: %s\n", strerror(-err));        exit(EXIT_FAILURE);    }    if (err = rt_mutex_create(&mutexOSD, NULL)) {        rt_printf("Error mutex create: %s\n", strerror(-err));        exit(EXIT_FAILURE);    }    if (err = rt_mutex_create(&mutexCommande, NULL)) {        rt_printf("Error mutex create: %s\n", strerror(-err));        exit(EXIT_FAILURE);    }    if (err = rt_mutex_create(&mutexCommande, NULL)) {        rt_printf("Error mutex create: %s\n", strerror(-err));        exit(EXIT_FAILURE);    }    /* Creation du semaphore */    if (err = rt_sem_create(&semDemarrage, NULL, 0, S_FIFO)) {        rt_printf("Error semaphore create: %s\n", strerror(-err));        exit(EXIT_FAILURE);    }    if (err = rt_sem_create(&semImageCapturee, NULL, 0, S_FIFO)) {        rt_printf("Error semaphore create: %s\n", strerror(-err));        exit(EXIT_FAILURE);    }    /* Creation des taches */    if (err = rt_task_create(&tth_controler, NULL, 0, PRIORITY_THCONTROLER, 0)) {        rt_printf("Error task create: %s\n", strerror(-err));        exit(EXIT_FAILURE);    }    if (err = rt_task_create(&tth_capture, NULL, 0, PRIORITY_THCAPTURE, 0)) {        rt_printf("Error task create: %s\n", strerror(-err));        exit(EXIT_FAILURE);    }    if (err = rt_task_create(&tth_display, NULL, 0, PRIORITY_THDISPLAY, 0)) {        rt_printf("Error task create: %s\n", strerror(-err));        exit(EXIT_FAILURE);    }    /* Creation des files de messages */    if (err = rt_queue_create(&queueMsgGUI, "toto", MSG_QUEUE_SIZE*sizeof(DMessage), MSG_QUEUE_SIZE, Q_FIFO)){        rt_printf("Error msg queue create: %s\n", strerror(-err));        exit(EXIT_FAILURE);    }}void startTasks() {    int err;    if (err = rt_task_start(&tth_controler, &th_controler, NULL)) {        rt_printf("Error task start: %s\n", strerror(-err));        exit(EXIT_FAILURE);    }    if (err = rt_task_start(&tth_capture, &th_capture, NULL)) {        rt_printf("Error task start: %s\n", strerror(-err));        exit(EXIT_FAILURE);    }    if (err = rt_task_start(&tth_display, &th_display, NULL)) {        rt_printf("Error task start: %s\n", strerror(-err));        exit(EXIT_FAILURE);    }}void deleteTasks() {    rt_task_delete(&tth_controler);    rt_task_delete(&tth_capture);    rt_task_delete(&tth_display);}
